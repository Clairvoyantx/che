#
# Copyright (c) 2012-2017 Codenvy, S.A.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#   Codenvy, S.A. - initial API and implementation
#

### CHE SERVER
# Folder where Che will store internal data objects
che.database=<%= scope.lookupvar('che::che_database') %>

# API service. Browsers initiate REST communications to Che server with this URL
che.api=<%= scope.lookupvar('che::che_api') %>

# Your projects are synchronized from the Che server into the machine running each
# workspace. This is the directory in the ws runtime where your projects are mounted.
che.workspace.storage=<%= scope.lookupvar('che::che_workspace_storage') %>

# Your projects are synchronized from the Che server into the machine running each
# workspace. This is the directory in the machine where your projects are placed.
che.workspace.projects.storage=<%= scope.lookupvar('che::che_workspace_projects_storage') %>

# Configures proxies used by runtimes powering workspaces
che.workspace.http_proxy=<%= scope.lookupvar('che::che_workspace_http__proxy') %>
che.workspace.https_proxy=<%= scope.lookupvar('che::che_workspace_https__proxy') %>
che.workspace.no_proxy=<%= scope.lookupvar('che::che_workspace_no__proxy') %>

# Configures dns resolving servers. May contain several values separated by comma sign.
che.dns.resolvers=<%= scope.lookupvar('che::che_dns_resolvers') %>

# During the stop of the workspace automatically creates a snapshot if the value is {true},
# Otherwise just stops the workspace.
che.workspace.auto_snapshot=<%= scope.lookupvar('che::che_workspace_auto__snapshot') %>

# During the start of the workspace automatically restore it from a snapshot if the value is {true},
# Otherwise create a new workspace.
che.workspace.auto_restore=<%= scope.lookupvar('che::che_workspace_auto__restore') %>

# By default, when users access to a workspace with its URL the workspace
# automatically starts if it is stopped. You can set this to false to disable this.
che.workspace.auto_start=<%= scope.lookupvar('che::che_workspace_auto__start') %>

# Workspace threads pool configuration, this pool is used for workspace related
# operations that require asynchronous execution e.g. starting/stopping/snapshotting

# possible values are 'fixed', 'cached'
che.workspace.pool.type=<%= scope.lookupvar('che::che_workspace_pool_type') %>

# This property is ignored when pool type is different from 'fixed'.
# Configures the exact size of the pool, if it's set multiplier property is ignored.
# If this property is not set(0, < 0, NULL) then pool sized to number of cores,
#it can be modified within multiplier
che.workspace.pool.exact_size=<%= scope.lookupvar('che::che_workspace_pool_exact__size') %>

# This property is ignored when pool type is different from 'fixed' or exact pool size is set.
# If it's set the pool size will be N_CORES * multiplier
che.workspace.pool.cores_multiplier=<%= scope.lookupvar('che::che_workspace_pool_cores__multiplier') %>

# Java command line options used to start Che agent in workspace runtime
che.workspace.java.options=<%= scope.lookupvar('che::che_workspace_java_options') %> <% if ! @che_workspace_http__proxy.empty? or ! @che_workspace_https__proxy.empty? -%>-Dhttp.proxySet=true<% end -%><% if ! @che_workspace_http__proxy.empty? -%><% if ! @che_workspace_http__proxy.empty? and @che_workspace_http__proxy.include? '@' -%> -Dhttp.proxyUser=<%= @che_workspace_http__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split('@')[0].split(':')[0] %> -Dhttp.proxyPassword=<%= @che_workspace_http__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split('@')[0].split(':')[1] %> -Dhttp.proxyHost=<%= @che_workspace_http__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split('@')[1].split(':')[0] %> -Dhttp.proxyPort=<%= @che_workspace_http__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split('@')[1].split(':')[1].gsub(/\/.*/,'') %><% else -%> -Dhttp.proxyHost=<%= @che_workspace_http__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split(':')[0] %> -Dhttp.proxyPort=<%= @che_workspace_http__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split(':')[1].gsub(/\/.*/,'') %><% end -%><% end -%><% if ! @che_workspace_https__proxy.empty? -%><% if @che_workspace_https__proxy.include? '@' -%> -Dhttps.proxyUser=<%= @che_workspace_https__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split('@')[0].split(':')[0] %> -Dhttps.proxyPassword=<%= @che_workspace_https__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split('@')[0].split(':')[1] %> -Dhttps.proxyHost=<%= @che_workspace_https__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split('@')[1].split(':')[0] %> -Dhttps.proxyPort=<%= @che_workspace_https__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split('@')[1].split(':')[1].gsub(/\/.*/,'') %><% else -%> -Dhttps.proxyHost=<%= @che_workspace_https__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split(':')[0] %> -Dhttps.proxyPort=<%= @che_workspace_https__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split(':')[1].gsub(/\/.*/,'') %><% end -%><% end -%><% if ! @che_no_proxy.empty? -%> -Dhttp.nonProxyHosts='<%= @che_workspace_no__proxy.gsub(/^https?\:\/\//, '').gsub(/^www./,'').split(",").uniq.join("|") %>|'<% end -%>

# Maven command line options will be exported as value of MAVEN_OPTS
# environment variable in workspace dev-machine.
# If the value is not set then the value provided by 'che.workspace.java.options' property is used
che.workspace.maven.options=<%= scope.lookupvar('che::che_workspace_maven_options') %>

# Folder that will be a volume mount from your host into your workspace.
che.workspace.volume=<%= scope.lookupvar('che::che_workspace_volume') %>

# If your workspace creates SSH connections, their timeouts are managed by this property.
che.workspace.ssh_connection_timeout_ms=<%= scope.lookupvar('che::che_workspace_ssh__connection__timeout__ms') %>

# The location of the Web terminal used within the browser.
# This is copied into the workspace and runs within the workspace.
# Suffix helps differentiate archive for different architectures/OSes
che.workspace.terminal_linux_amd64=<%= scope.lookupvar('che::che_workspace_terminal__linux__amd64') %>
che.workspace.terminal_linux_arm7=<%= scope.lookupvar('che::che_workspace_terminal__linux__arm7') %>

# Folder where the workspace will store logs from agents and other runtimes
che.workspace.logs=<%= scope.lookupvar('che::che_workspace_logs') %>

# RAM default for new machines.
# TODO: is this per machine, or for the entire environment?
che.workspace.default_memory_mb=<%= scope.lookupvar('che::che_workspace_default__memory__mb') %>

# This archive contains the server to run the workspace agent and any custom extensions.
# Che injects this archive into machines when they are booted or started.
# Each machine can have many agents installed, each located in a different location.
che.workspace.agent.dev=<%= scope.lookupvar('che::che_workspace_agent_dev') %>

# Hosts listed here will be added to /etc/hosts of each workspace.
che.workspace.hosts=<%= scope.lookupvar('che::che_workspace_hosts') %>

# This is the API endpoint of the workspace master running within the core Che server.
# This tells the workspace agent how to connect back to the Che server.
# che-host is a hostname entry added to /etc/hosts of the workspace by the Che server.
che.workspace.che_server_endpoint=<%= scope.lookupvar('che::che_workspace_che__server__endpoint') %>

### AGENTS
# When the Che server launches a new workspace, Che pings a mini Che server running inside of the
# workspace runtime. We call this mini-Che an "agent". The Che server knows that the workspace
# is ready for user when the agent returns a valid response.
che.workspace.agent.dev.max_start_time_ms=<%= scope.lookupvar('che::che_workspace_agent_dev_max__start__time__ms') %>
che.workspace.agent.dev.ping_delay_ms=<%= scope.lookupvar('che::che_workspace_agent_dev_ping__delay__ms') %>
che.workspace.agent.dev.ping_conn_timeout_ms=<%= scope.lookupvar('che::che_workspace_agent_dev_ping__conn__timeout__ms') %>
che.workspace.agent.dev.ping_timeout_error_msg=<%= scope.lookupvar('che::che_workspace_agent_dev_ping__timeout__error__msg') %>

che.agent.dev.max_start_time_ms=<%= scope.lookupvar('che::che_agent_dev_max__start__time__ms') %>
che.agent.dev.ping_delay_ms=<%= scope.lookupvar('che::che_agent_dev_ping__delay__ms') %>

### TEMPLATES
# Folder that contains JSON files with code templates and samples
che.template.storage=<%= scope.lookupvar('che::che_template_storage') %>

### STACKS
# File name containing default stacks definitions
che.stacks.storage=<%= scope.lookupvar('che::che_stacks_storage') %>

# che.stacks.default=${che.home}/stacks/stacks.json
# Folder name where stack images are stored
che.stacks.images=<%= scope.lookupvar('che::che_stacks_images') %>

### AUTHENTICATION PARAMETERS
# Che has a single identity implementation, so this does not change the user experience.
# If true, enables user creation at API level
che.auth.user_self_creation=<%= scope.lookupvar('che::che_auth_user__self__creation') %>

che.auth.access_denied_error_page=<%= scope.lookupvar('che::che_auth_access__denied__error__page') %>

# Reserved user names
che.auth.reserved_user_names=<%= scope.lookupvar('che::che_auth_reserved__user__names') %>

# You can setup GitHub oAuth to automate authentication to remote repositories.
# You need to first register this application with GitHub oAuth.
che.oauth.github.clientid=<%= scope.lookupvar('che::che_oauth_github_clientid') %>
che.oauth.github.clientsecret=<%= scope.lookupvar('che::che_oauth_github_clientsecret') %>
che.oauth.github.authuri=<%= scope.lookupvar('che::che_oauth_github_authuri') %>
che.oauth.github.tokenuri=<%= scope.lookupvar('che::che_oauth_github_tokenuri') %>
che.oauth.github.redirecturis=<%= scope.lookupvar('che::che_oauth_github_redirecturis') %>


### DOCKER PARAMETERS
# Docker is the default machine implementation within Che. Workspaces are powered by machines
# that are constructed when the workspace is started. The images used to generate containers
# for the machines can come from DockerHub or a private Docker registry.
che.docker.registry=<%= scope.lookupvar('che::che_docker_registry') %>

# If this is true, then we always pull an image from a registry even if we have an image cached
# locally. If false, Docker only pulls image if it does not exist locally.
che.docker.always_pull_image=<%= scope.lookupvar('che::che_docker_always__pull__image') %>

# If true, then launches all workspace runtime containers with Docker's
# privileged mode. Please use responsibly. This is required if you want Che workspaces
# to be able to launch their own runtimes which are embedded Docker containers.
che.docker.privileged=<%= scope.lookupvar('che::che_docker_privileged') %>

# Limits the number of processes that can be forked inside a cgroup. Set -1 for unlimited.
# Since 4.3 kernel.
che.docker.pids_limit=<%= scope.lookupvar('che::che_docker_pids__limit') %>

# Sets parent cgroup for cgroups of containers created by workspaces.
# This allows an admin to set custom cgroup limitations to all containers of workspaces by configuring cgroups.
# Example:
# /my_group
# my_another_group
che.docker.parent_cgroup=<%= scope.lookupvar('che::che_docker_parent__cgroup') %>

# Sets set of CPUs that can be used by each container of started workspace.
# Example:
# 0-3
# 1,4
che.docker.cpuset_cpus=<%= scope.lookupvar('che::che_docker_cpuset__cpus') %>

# Next 2 properties set limits on CPU consumption by containers of started workspaces.
# Period sets amount of units per CPU core.
# Quota sets amount of units available for container per whole CPU.
# Max value of quota could be period * number of CPU cores in a system.
# Example:
# che.docker.cpu_period=5000
# che.docker.cpu_quota=10000
che.docker.cpu_period=<%= scope.lookupvar('che::che_docker_cpu__period') %>
che.docker.cpu_quota=<%= scope.lookupvar('che::che_docker_cpu__quota') %>

# Adds options when mounting the /projects volume.
che.docker.volumes_projects_options=<%= scope.lookupvar('che::che_docker_volumes__projects__options') %>

# Adds options when mounting the /mnt/che/terminal, /mnt/che/ws-agent.tar.gz, /mnt/che/conf volume
che.docker.volumes_agent_options=<%= scope.lookupvar('che::che_docker_volumes__agent__options') %>

# If the browser clients that are accessing Che are remote AND the configuration of Docker is an
# internal IP address or using Unix sockets, then remote browser clients will not be able to connect
# to the workspace. Set the Docker configuration so that Docker containers have an external IP
# address and provide that external host or IP address here.
# This is uncommon, and only needed for advanced Docker configurations.
che.docker.ip=<%= scope.lookupvar('che::che_docker_ip') %>

# The hostname that a browser should use to connect to a workspace container.
# Only set this if your workspace containers are not directly pingable.
# This is unusual, but happens for example in Docker for Mac when containers are in a VM.
che.docker.ip.external=<%= scope.lookupvar('che::che_docker_ip_external') %>

# The server evaluation strategy to be used to determine servers exposed by workspaces.
# Options:
#   - 'default':      internal address is address of docker host and ephemeral port are used
#   - 'docker-local': internal address is address of container within docker network, and exposed ports
#                     are used.
# The 'docker-local' strategy may be useful if a firewall prevents communication between che-server and
# workspace containers, but will prevent communication when che-server and workspace containers are not
# on the same Docker network.
che.docker.server_evaluation_strategy=<%= scope.lookupvar('che::che_docker_server__evaluation__strategy') %>

# Provides a Docker network where Che server is running.
# Workspace containers created by Che will be added to this Docker network.
# Communications between the Che server and container occur over this network.
che.docker.network=<%= scope.lookupvar('che::che_docker_network') %>

# Use a Docker registry for workspace snapshots. If false, snaps are saved to disk.
che.docker.registry_for_snapshots=<%= scope.lookupvar('che::che_docker_registry__for__snapshots') %>

# Registry snapshot namespace
che.docker.namespace=<%= scope.lookupvar('che::che_docker_namespace') %>

# Docker unused containers and networks cleanup period
che.docker.cleanup_period_min=<%= scope.lookupvar('che::che_docker_cleanup__period__min') %>

# Version number of the Docker API used within the Che implementation
che.docker.api=<%= scope.lookupvar('che::che_docker_api') %>

che.docker.network_driver=<%= scope.lookupvar('che::che_docker_network__driver') %>

che.docker.tcp_connection_timeout_ms=<%= scope.lookupvar('che::che_docker_tcp__connection__timeout__ms') %>
che.docker.tcp_connection_read_timeout_ms=<%= scope.lookupvar('che::che_docker_tcp__connection__read__timeout__ms') %>

# Docker registry example. Uncomment to add a registry configuration.
# You can configure multiple registries with different names.
#che.docker.registry.auth.<insert-name>.url=https://index.docker.io/v1/
#che.docker.registry.auth.<insert-name>.username=<username>
#che.docker.registry.auth.<insert-name>.password=<password>

# Allows to adjust machine swap memory by multiplying current machnine memory to provided value.
# default is -1 which is unlimited swap. If set, value is multipled by machine memory set by user
# to determine swap size. To disable swap set to 0.
che.docker.swap=<%= scope.lookupvar('che::che_docker_swap') %>

### INTERNAL
# Remove locations where internal message bus events should be propagated to.
# For debugging - set to retrieve internal events from external clients.
notification.server.propagate_events=<%= scope.lookupvar('che::notification_server_propagate__events') %>

# Che extensions can be scheduled executions on a time basis.
# This configures the size of the thread pool allocated to extensions that are launched on
# a recurring schedule.
schedule.core_pool_size=<%= scope.lookupvar('che::schedule_core__pool__size') %>

# Everrest is a Java Web Services toolkit that manages JAX-RS & web socket communications
# Users should rarely need to configure this.
# Disable asynchronous mechanism that is embedded in everrest.
org.everrest.asynchronous=<%= scope.lookupvar('che::org_everrest_asynchronous') %>
# Quantity of asynchronous requests which may be processed at the same time
org.everrest.asynchronous.pool.size=<%= scope.lookupvar('che::org_everrest_asynchronous_pool_size') %>
# Size of queue. If asynchronous request can't be processed after consuming it will be added in queue.
org.everrest.asynchronous.queue.size=<%= scope.lookupvar('che::org_everrest_asynchronous_queue_size') %>
# Timeout in minutes for request. If after timeout request is not done or client did not come yet to get result of request it may be discarded.
org.everrest.asynchronous.job.timeout=<%= scope.lookupvar('che::org_everrest_asynchronous_job_timeout') %>
# Size of cache for waiting, running and ended request.
org.everrest.asynchronous.cache.size=<%= scope.lookupvar('che::org_everrest_asynchronous_job_timeout') %>
# Path to asynchronous service
org.everrest.asynchronous.service.path=<%= scope.lookupvar('che::org_everrest_asynchronous_service_path') %>

# DB initialization and migration configuration
db.schema.flyway.baseline.enabled=<%= scope.lookupvar('che::db_schema_flyway_baseline_enabled') %>
db.schema.flyway.baseline.version=<%= scope.lookupvar('che::db_schema_flyway_baseline_version') %>
db.schema.flyway.scripts.prefix=<%= scope.lookupvar('che::db_schema_flyway_scripts_prefix') %>
db.schema.flyway.scripts.suffix=<%= scope.lookupvar('che::db_schema_flyway_scripts_suffix') %>
db.schema.flyway.scripts.version_separator=<%= scope.lookupvar('che::db_schema_flyway_scripts_version__separator') %>
db.schema.flyway.scripts.locations=<%= scope.lookupvar('che::db_schema_flyway_scripts_locations') %>
db.jndi.datasource.name=<%= scope.lookupvar('che::db_jndi_datasource_name') %>

# OpenShift related properties
che.openshift.project=<%= scope.lookupvar('che::che_openshift_project') %>
che.openshift.serviceaccountname=<%= scope.lookupvar('che::che_openshift_serviceaccountname') %>
che.openshift.liveness.probe.delay=<%= scope.lookupvar('che::che_openshift_liveness_probe_delay') %>
che.openshift.liveness.probe.timeout=<%= scope.lookupvar('che::che_openshift_liveness_probe_timeout') %>

# Which implementation of DockerConnector to use in managing containers. In general,
# the base implementation of DockerConnector is appropriate, but OpenShiftConnector
# is necessary for deploying Che on OpenShift. Options:
#     - 'default'   : Use DockerConnector
#     - 'openshift' : use OpenShiftConnector
che.docker.connector=<%= scope.lookupvar('che::che_docker_connector') %>
